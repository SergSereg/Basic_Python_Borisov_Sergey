# #++++++++++++++++++++++++++++++++++++++++++++++++
# # Задачи на input() и print()
# #++++++++++++++++++++++++++++++++++++++++++++++++
# #================================================
# # 1. Простая работа с print()
# #================================================
print("Привет, мир!")
print(5, 10, 15)
print(10 + 25)

# #================================================
# # 2. Использование параметров sep и end в print()
# #================================================
print(1, 2, 3, sep=" & ") # Выводим 1, 2, 3 через " & " с помощью sep

print("Python", end=" ") # Выводим "Python" и "лучший язык" в одной строке, используя end
print("лучший язык")

# #================================================
# # 3. Форматированный вывод с F-строками
# #================================================
x = 3.14
y = -8
print(f"Координаты точки: x = {x}; y = {y}")

name = input("Введите имя: ")
age = input("Введите возраст: ")

# age = int(age)  # В реальных тестах — ловить(писать)

print(f"Имя: {name}, Возраст: {age}")

# #================================================
# # 4. Работа с input()
# #================================================
name = input("Введите имя: ") # Запрашиваем имя у пользователя

print(f"Привет, {name}!")  # Выводим приветствие с f-строки (современный и читаемый способ)

# #================================================
# # 5. Преобразование типов
# #================================================
num_1 = float(input("Введите первое число: ")) # → float, чтобы работало и с 3.5
num_2 = float(input("Введите второе число: "))
print(num_1 + num_2)

n = int(input("Введите целое число:"))  # → int, так как требуется "целое"
print(n ** 2)   # →  вывод квадрата

# #++++++++++++++++++++++++++++++++++++++++++++++++
# # Булевые значения
# #++++++++++++++++++++++++++++++++++++++++++++++++
# #================================================
# # 1. Основы булевой логики
# #================================================
print(5 > 3)  # → True
print(10 < 2) # → False
print(7 == 7) # → True
print(6 != 8) # → True
print(4 >= 4) # → True
print(9 <= 3) # → False

res = 8 > 12     # 8 > 12 → False
print(res)       # → False
print(type(res)) # → <class 'bool'>

# #================================================
# # 2. Проверка четности и кратности числа
# #================================================
x = 15

print(x % 2 == 0) # Проверяем, чётное ли x (остаток от деления на 2 == 0) → False (15 — нечётное)
print(x % 5 == 0) # Проверяем, делится ли x на 5 без остатка → True (15 ÷ 5 = 3, остаток 0)
print(x % 3 == 0 and x % 5 == 0) # Проверяем, делится ли x одновременно на 3 и 5

# #================================================
# # 3. Работа с логическими операторами (and, or, not)
# #================================================
y = 4.5

print(y >= 1 and y <=10) # → True (4.5 между 1 и 10) Используем `and`: оба условия должны быть True

print((y >= 0 and y <= 5) or (y >= 10 and y <=15)) # Проверяем: y в [0, 5] ИЛИ [10, 15] Используем `or`: достаточно одного True

print(not (y < 5)) # 4. Инвертируем y < 5 с помощью `not`  False (т.к. y=4.5 < 5 → True, not True = False)

# #================================================
# # 4. Приоритет логических операций
# #================================================
print(True or False and False) # → True
print(not False and True)      # → True
print(False or not True and True)  # → False
print(not (10 > 5 or 3 < 1))       # → False

# #================================================
# # 5. Приведение типов к bool
# #================================================
print(bool(0))    # → False
print(bool(-5))   # → True
print(bool(3.14)) # → True
print(bool(""))   # → False (пустая строка)
print(bool("Python")) # → True
print(bool(" "))      # → True (пробел — это символ!)

# #================================================
# # 6. Дополнительное задание
# #================================================
n = 12

is_positive = n > 0
is_even = n % 2 ==0
divisible_by_3 = n % 3 == 0

result = is_positive and is_even and divisible_by_3 # Объединяем: ВСЕ три условия должны быть True → используем `and`

print(f"Число: {n}")
print(f"Положительное: {is_positive}")
print(f"Четное: {is_even}")
print(f"Делится на 3: {divisible_by_3}")
print(f"Все условия выполнены: {result}")

# #++++++++++++++++++++++++++++++++++++++++++++++++
# # Срезы строк
# #++++++++++++++++++++++++++++++++++++++++++++++++
# #================================================
# # 1. Доступ к символам по индексу.
# #================================================
s = "Программирование"

print(s[0])        # → 'П' Первый символ → индекс 0

print(s[-1])       # → 'е' Последний символ → индекс -1 (отсчёт с конца)

print(s[2])        # → 'о' Третий символ → индекс 2 (0, 1, 2 → третий!)

print(s[-2])       # → 'и' Предпоследний символ → индекс -2

# #================================================
# # 2. Обращение к символам с проверкой границ
# #================================================
s = "Программирование"
# print(s[100])  # ❌ IndexError: string index out of range

last_index = len(s) - 1   # длина строки минус 1 → индекс последнего символа

print(s[last_index]) # → 'е'
# print(s[-1])  # → 'е' (то же самое, но короче)

# #================================================
# # 3. Создание срезов
# #================================================
s = "Программирование"

first_6 = s[0:6] # Первые 6 символов → индексы 0,1,2,3,4,5 → s[0:6]
print(first_6)   # → "Програ"

last_5 = s[-5:]  # Последние 5 символов → с индекса -5 до конца → s[-5:]
print(last_5)    # → "вание"

middle = s[2:7] # С 3-го по 7-й символ → индексы 2,3,4,5,6 (7-й — индекс 6!) → s[2:7]
print(middle)   # → "ограм"

every_second = s[::2] # Каждый второй символ → шаг 2 → s[::2]
print(every_second)   # → "Пормрвне"

reversed_s = s[::-1]  # Развернуть строку → шаг -1 → s[::-1]
print(reversed_s)     # → "еинавормиргорП"

# #================================================
# # 4. Работа с шагом в срезах
# #================================================
s = "Программирование"
# every_third = s[::3] # лучше писать новую переменную для дальнейшей работы с ней, а не сразу выводить
# print(every_third)
print(s[::3])   # →  Каждый третий, начиная с первого (индекс 0) → Пгмрае
print(s[::-2])  # →  Обратный порядок, через один (шаг -2) → енврмагр

# 2 вариант лучше для AQA?
s = "Программирование"

every_third = s[0::3]
print(every_third)

reversed_every_other = s[::-2]
print(reversed_every_other)

# #================================================
# # 5. Проверка неизменяемости строк
# #================================================
s = "программирование"
# s[0] = "п"  # ❌ TypeError

s2 = "П" + s[1:]  # безопасная замена через срезы
print(s2)

# #================================================
# # 6. Дополнительное задание
# #================================================
word = "abcdefgh"

cde = word[2:5] # 'c' — индекс 2, 'e' — индекс 4 → срез [2:5] (5 не включается!)
print(cde)

reversed_word = word[::-1] #  Обратный порядок — шаг -1
print(reversed_word)

middle = word[1:-1] #Без первого и последнего символов.Первый — индекс 0, последний — -1 → берём с 1 по -1 (не включая!)
print(middle)